% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/db-eval.R
\name{db.eval}
\alias{db.eval}
\title{Evaluate SQL statements}
\usage{
db.eval(db, stmt, params, df = getOption("DBPKG_DATAFRAME_RETURN", FALSE))
}
\arguments{
\item{db}{The database connection. An S4 object of class "database".}

\item{stmt}{The SQL statement to evaluate. SQL parameters can be
bound to the statement and are indicated by the '?' character.}

\item{params}{A matrix, data.frame, or list of lists with parameters
to bind the SQL stmt. Each row in the matrix or data.frame or each
sublist in the list of lists corresponds to a single parameter set.
The number of parameters in each parameter set should equal the
number of '?' characters in the SQL statement. If multiple parameter
sets are bound to the statement then the statement may not be a
SELECT statement. For the common case when there is only a single parameter
set it is permitted to pass an atomic vector or a single list (i.e., no
sublists) with the parameter values to bind.}

\item{df}{A boolean. Should the result be returned as a data.frame?}
}
\value{
The result of a SELECT statement or NULL if the
statement is not a SELECT. Results will be returned as
a matrix (df=FALSE) or data.frame (df=TRUE) containing the rows
from the result set. If \code{df=FALSE} subsets of the matrix will
return lists rather than atomic vectors. This is necessary because
elements of the matrix can hold any type of object that are not
necessarily the same from one element to the next.
}
\description{
Evaluate SQL statements
}
\examples{
db = db.open()
db.eval(db, "CREATE TABLE foo(f1 TEXT)")
db.eval(db, "INSERT INTO foo VALUES (?)", list("hello"))
db.eval(db, "INSERT INTO foo VALUES (?)", c("world"))
db.eval(db, "INSERT INTO foo VALUES (?)", data.frame(letters))
db.eval(db, "INSERT INTO foo VALUES (?)", matrix("goodbye", 1, 1))
db.eval(db, "SELECT * FROM foo")
db.close(db)
}
