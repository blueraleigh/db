% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/db-vtable.R
\name{new.virtualtable}
\alias{new.virtualtable}
\title{Create a virtual table module}
\usage{
new.virtualtable(name, methods, env = new.env())
}
\arguments{
\item{name}{The name of the virtual table module}

\item{methods}{A named list of functions implementing the virtual table
methods. See details.}
}
\value{
A function that can be used to register the virtual table
module with a database connection.
}
\description{
Create a virtual table module
}
\details{
A virtual table acts like a regular database table except that
SQL statements invoke callback methods defined by the virtual table
module. In the current implementation there are 13 methods that can be
written. Not all of these methods are required as some have sensible
defaults. Each section below starts by showing the formal arguments each
method is expected to have, followed by a description of the method. To be
clear, these methods are typically not invoked by the user. Rather, they are
invoked automatically when an SQL statement is run against a virtual table.
The SQLite core will communicate the arguments to the different methods.
}
\section{The \code{.create} method}{

function(db, table, ...)

The \code{.create} function is called whenever a new virtual table
is created by a CREATE VIRTUAL TABLE statement. The function should return
a new environment for the virtual table, which can be used to store data
that needs to be communicated among the different callbacks. At a minimum,
the returned environment should contain a \code{'schema'} variable, which
is a scalar character vector specifying the SQL schema of the
virtual table.

Argument \code{table} is the name of the virtual table being created.
The \code{...} contain additional arguments specified as part of the
CREATE VIRTUAL TABLE statement. For example, the statement \preformatted{
    CREATE VIRTUAL TABLE tablename USING modulename(arg1, arg2, arg3)
}
will call the \code{.create} function with argument \code{table} set equal to
'tablename' and with module arguments arg1, arg2, arg3 passed through
to \code{...}

Note that virtual tables can be associated with regular tables
that provide a persistent data store. In this case, regular tables
tables should follow a strict naming convention like so \preformatted{
    <virtual table name>_<persistent table name>
}
Furthermore, it is imperative that the \code{.create} and \code{.connect}
function call db.register_shadowname with <persistent table name> as the
\code{name} argument. Failure to do so will allow ordinary SQL to alter
the contents of the data store. Calling db.register_shadowname
ensures that SQL can alter the data store contents only if it
originates from within one of the virtual table's methods.
}

\section{The \code{.connect} method}{

function(db, table, ...)

The \code{.connect} function is called whenever a database connects
to or reparses a virtual table schema. It receives the same arguments
as the \code{.create} function. The only time the \code{.create} and
\code{.connect} functions are different is when the \code{.create} function
needs to do some initialization work to set up a persistent data store
in the form of real database tables.
}

\section{The \code{.disconnect} method}{

function(db, table, env)

The \code{.disconnect} function is called whenever a database connection that
uses a virtual table is closed. The default method does nothing.
}

\section{The \code{.destroy} method}{

function(db, table, env)

The \code{.destroy} function is called whenever a virtual table is deleted by
a DROP TABLE statement. The default method does nothing.
}

\section{The \code{.open} method}{

function(db, table, env)

The \code{.open} function is called whenever a cursor is needed to access
rows of a virtual table. The default method creates a variable named "rowid"
in \code{env} and assigns it the value of 1.
}

\section{The \code{.close} method}{

function(db, table, env)

The \code{.close} function is called whenever a previously opened cursor is
no longer needed. The default method does nothing.
}

\section{The \code{.rowid} method}{

function(db, table, env)

The \code{.rowid} function returns the rowid of the row of data the cursor is
currently pointing to. The default method returns the current value bound to
"rowid" in \code{env}.
}

\section{The \code{.next} method}{

function(db, table, env)

The \code{.next} function advances the cursor to the next row of data.
The default method increments the current value bound to "rowid" in
\code{env} by 1.
}

\section{The \code{.eof} method}{

function(db, table, env)

The \code{.eof} function determines if the cursor has advanced passed the
last row of data. The default method returns \code{TRUE}.
}

\section{The \code{.column} method}{

function(db, table, env, j)

The \code{.column} function returns the value in the j-th column for the
current row of data. The default method does nothing.
}

\section{The \code{.insert} method}{

function(db, table, env, rid, ...)

The \code{.insert} function is called in response to an INSERT statement on
a virtual table. If it returns NULL the table is marked
as read only and the operation is prohibited. The default method returns
NULL.

Values in \code{...} contain the data being inserted. The values will be in
the same length and order as the table's declared columns. Any columns not
supplied in the insert statement will be represented as \code{NA} in \code{...}
The rowid for the new row is given by \code{rid}. If \code{rid} is \code{NA}
then the \code{.insert} function is responsible for choosing a new rowid.

The function should return the value of the newly inserted rowid.
}

\section{The \code{.update} method}{

function(db, table, env, rid, oid, ...)

The \code{.update} function is called in response to an
UPDATE statement on a virtual table. If it returns NULL the table is marked
as read only and the operation is prohibited. The default method returns
NULL.

Values in \code{...} contain the data being modified. The values will be in
the same length and order as the table's declared columns. Any columns not
supplied in the update statement will be represented as \code{NA} in \code{...}

\code{oid} indicates the rowid of the data being modified. If \code{rid != oid}
then this indicates that the rowid of the updated row is
being changed from \code{oid} to \code{rid}.

The function should return \code{NA}.
}

\section{The \code{.delete} method}{

function(db, table, env, rid)

The \code{.delete} function is called in response to a DELETE
statement on a virtual table. If it returns NULL the table is marked
as read only and the operation is prohibited. The default method returns
NULL.

\code{rid} indicates the rowid of data to be deleted.

The function should return \code{NA}.
}

\section{The \code{.bestindex} method}{

function(db, table, env, constraints, orderbys)

This is a complicated method. For starters, it is best to just leave it as
the default, which is to return NULL.

The \code{.bestindex} function determines the best index to
use to efficiently perform a SQL query.

Argument \code{constraints} will be a list of usable constraints that
comprise the query. Each element in the list is a vector
of length 2. The first element is the column index that
the constraint operates on; the second, the type of
constraint operator. If the column index is 0, this
indicates the constraint operates on the table's rowid.

Argument \code{orderbys} is a list of order by terms. Each
element in the list is also a vector of length 2.
The first element is the column index of the order by term;
the second, an integer indicating if the order by term is
decreasing (1) or increasing (0).

The job of \code{.bestindex} is to use this information to select
an index to perform the query and communicate this back
to SQLite. The return value should be a list with the following
structure.

The first element in the list should be an integer vector
of the same length as the input \code{constraints} list. If no
index is available for a given constraint, then the corresponding
value in this vector should be set to \code{NA}, indicating a full
table scan is necessary to get the desired result. If an index
is available, then the corresponding value in this vector should
be set to the position the constraint argument will appear in the \code{...}
arguments passed to the \code{.filter} function (see below). For example,
consider the following query
\preformatted{
  SELECT *
  FROM books
  WHERE author='Pratchett'
  AND subject='Discworld'
  AND pages >= 250
}
Now, consider that author is column 3, subject is column 1, and
pages is column 6, and that we are able to index on author and
subject.

The \code{constraints} input to \code{.bestindex} will look like
\preformatted{
[[1]]
[1] 3 SQLITE_INDEX_CONSTRAINT_EQ
[[2]]
[1] 1 SQLITE_INDEX_CONSTRAINT_EQ
[[3]]
[1] 6 SQLITE_INDEX_CONSTRAINT_GE
}
Suppose we want the subject to appear before the author in the \code{.filter} argument
list. Then the first item in the \code{.bestindex} list output should look like
\preformatted{
[1] 2 1 NA
}
Implying that the \code{...} arguments to filter will be \preformatted{
[[1]]
[1] 'Discworld'
[[2]]
[1] 'Pratchett'
}
If instead we had returned \preformatted{
[1] 1 2 NA
}
then the \code{...} arguments to filter would have been \preformatted{
[[1]]
[1] 'Pratchett'
[[2]]
[1] 'Discworld'
}
The second item in the \code{.bestindex} list output should be an integer
number used to identify the chosen index.

The third item in the \code{.bestindex} list output should be an character
string used to identify the chosen index.

The fourth item in the \code{.bestindex} list output should be TRUE if the
resulting output is already sorted according to the order by terms.
Otherwise it should be FALSE, indicating that SQLite needs to do
the sorting.

The fifth item in the \code{.bestindex} list output should be the estimated
cost of using the returned index to perform the query. SQLite will
call \code{.bestindex} multiple times with different inputs and will choose
the index that has the lowest estimated cost.
}

\section{The \code{.filter} method}{

function(db, table, env, idxnum, idxname, ...)

The \code{.filter} function sets the rowid to the rowid of
the first row of data in the result set. For starters, just leave this
function set to its default, which resets the "rid" variable in \code{env}
to 1.

The arguments are communicated to \code{.filter} by SQLite. Arguments
\code{idxnum} and \code{idxname} are set by the \code{.bestindex} function,
and the \code{.filter} function is free to interpret them however
it likes. If \code{.bestindex} function always returns NULL (the default),
\code{idxnum} will be 0 and \code{idxname} will be NULL. The remaining
arguments in \code{...} will be the constraint values in the
SQL query that \code{.bestindex} selected in the order that \code{.bestindex}
selected them. If \code{.bestindex} always returns NULL
then the \code{...} list will be empty.
}

